<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakura</title>
  <subtitle>Sakura&#39;s website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wy08271.github.io/"/>
  <updated>2016-12-11T14:43:13.000Z</updated>
  <id>https://wy08271.github.io/</id>
  
  <author>
    <name>Sakura</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习笔记：Git</title>
    <link href="https://wy08271.github.io/2016/10/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AGit/"/>
    <id>https://wy08271.github.io/2016/10/30/学习笔记：Git/</id>
    <published>2016-10-30T15:11:01.000Z</published>
    <updated>2016-12-11T14:43:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git基础用法"><a href="#Git基础用法" class="headerlink" title="Git基础用法"></a><strong>Git基础用法</strong></h2><ol>
<li><p>当需要回退到某个commit时，使用<code>git reset --hard commithash</code></p>
</li>
<li><p>当多人合作开发项目时，为了保证代码库commit序列的整洁，往往我们在push代码前都需要将本地的代码与远程代码库进行同步。这时候可以用<code>git pull 分支名 --rebase</code></p>
</li>
<li><p>如果git commit后发现有文件遗漏，可以使用<code>git add -u &lt;deleted file&gt;</code>,<code>git commit --amend</code></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git基础用法&quot;&gt;&lt;a href=&quot;#Git基础用法&quot; class=&quot;headerlink&quot; title=&quot;Git基础用法&quot;&gt;&lt;/a&gt;&lt;strong&gt;Git基础用法&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当需要回退到某个commit时，使用&lt;code&gt;
    
    </summary>
    
      <category term="note" scheme="https://wy08271.github.io/categories/note/"/>
    
    
      <category term="Git" scheme="https://wy08271.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记：ES6语法</title>
    <link href="https://wy08271.github.io/2016/08/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AES6%E8%AF%AD%E6%B3%95/"/>
    <id>https://wy08271.github.io/2016/08/01/学习笔记：ES6语法/</id>
    <published>2016-08-01T09:53:08.000Z</published>
    <updated>2016-12-11T14:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-let-和-const"><a href="#1-let-和-const" class="headerlink" title="1.let 和 const"></a>1.let 和 const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>ES6 引入了 <code>let</code> 用作声明变量，用法和之前的 <code>var</code> 类似，但是声明之后的效果却有很大的区别。</p>
<ul>
<li><code>let</code> 声明的变量作用域是块级的（block scope），<code>var</code> 声明名的变量是函数级的（function scope）。</li>
<li><code>let</code> 声明的变量不存在作用域提升。不像 <code>var</code>，如果先使用后声明会取得值 undefined。如果先使用再用 <code>let</code> 声明，会报错。</li>
<li><code>let</code> 在同一作用域下，不允许重复声明，而 <code>var</code> 可以。</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>const</code> 声明一个只读的常量。</p>
<ul>
<li><code>const</code> 声明的常量，一旦声明，就必须立即初始化，不能留到以后赋值。</li>
<li><code>const</code> 声明的常量作用域和 <code>let</code> 相同，也是块级的。</li>
<li><code>const</code> 声明的常量也不存在作用域提升。</li>
<li>在同一作用域下，和 <code>let</code> 一样，不能重复声明 <code>const</code> 常量。</li>
<li>对于引用类型的变量，<code>const</code> 声明只是保证变量名所指向的地址不变，并不保证改地址保存的数据不变。</li>
</ul>
<hr>
<h2 id="2-Destructuring"><a href="#2-Destructuring" class="headerlink" title="2. Destructuring"></a>2. Destructuring</h2><p>ES6允许按照一定模式，从数组或对象中提取值，对变量进行赋值，被称为解构（Destructuring）。其用法和 Ruby、Scala 等的模式匹配（Pattern Match）比较类似。</p>
<ul>
<li>数组</li>
</ul>
<p>只要等号两边的模式相同，等号左边的变量就会被赋予相应的值。有两种特殊情况，一种是等号右边的值不能被解构，这时左边的变量值为 <code>undefined</code>；另一种是不完全解构，即等号左边的模式只匹配右边部分值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var [a, b, c] = [1, 2, 3];</div><div class="line">//a = 1, b = 2, c = 3</div><div class="line"></div><div class="line">let [e, f] = [4, 5];</div><div class="line">//e = 4, f = 5</div><div class="line"></div><div class="line">const [x, , y] = [1, 2, 3];</div><div class="line">//x = 1, y = 3</div><div class="line"></div><div class="line">let [head, ...tail] = [1, 2, 3, 4];</div><div class="line">//head = 1, tail = [2, 3, 4]</div><div class="line"></div><div class="line">let [x, y, ...z] = [&apos;a&apos;];</div><div class="line">//x = &apos;a&apos;, y = undefined, z = []</div></pre></td></tr></table></figure>
<ul>
<li>对象</li>
</ul>
<p>字符串可以被转换成类似数组的对象，因此也可以解构赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [a, b, c, d] = &apos;peng&apos;;</div><div class="line">//a = &apos;p&apos;, b = &apos;e&apos;, c = &apos;n&apos;, d = &apos;g&apos;</div></pre></td></tr></table></figure>
<ul>
<li>数值 &amp; 布尔值</li>
</ul>
<p>函数的参数支持结构赋值，其规则和数组、对象的解构规则一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function add([x, y])&#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add([1, 2]); // 3</div><div class="line"></div><div class="line">function move(&#123;x, y&#125;) &#123;</div><div class="line">  return [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</div></pre></td></tr></table></figure>
<hr>
<h2 id="3-Template-String"><a href="#3-Template-String" class="headerlink" title="3. Template String"></a>3. Template String</h2><p>在 ES6 里面引入了模板字符串，用反引号标识。它可以当作普通单行字符串使用，也可以作为多行字符串使用，可以嵌入变量，函数调用。模板字符串中嵌入变量，需要将变量名或函数调用写在${ }之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var [x, y] = [1, 2];</div><div class="line"></div><div class="line">`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`</div><div class="line">// &quot;1 + 4 = 5&quot;</div><div class="line"></div><div class="line">function fn() &#123;</div><div class="line">  return &quot;Hello World&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">`foo $&#123;fn()&#125; bar`</div><div class="line">//foo Hello World bar</div></pre></td></tr></table></figure>
<hr>
<h2 id="4-Class"><a href="#4-Class" class="headerlink" title="4. Class"></a>4. Class</h2><p>JavaScript 在 ES6 之前，定义对象都是通过构造函数的方式进行的。如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Point(x,y)&#123;</div><div class="line">  this.x = x;</div><div class="line">  this.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point.prototype.toString = function () &#123;</div><div class="line">  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ES6 引入了 <code>extends</code> 关键字， <code>class</code> 之间可以通过 <code>extends</code> 很方便的实现继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class ColorPoint extends Point &#123;</div><div class="line">  constructor(x, y, color) &#123;</div><div class="line">    super(x, y); // 调用父类的constructor(x, y)</div><div class="line">    this.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里在 <code>constructor</code> 和 <code>toString</code> 方法中都出现了 <code>super</code> 关键字。这个关键字有两种用法，一种是作为函数调用，此时 <code>super</code> 代表父类的 <code>constructor</code> 方法；另一种是作为对象调用，此时 <code>super</code> 代表的是父类，既可以应用父类实例的方法和属性，也可以引用父类的静态方法。如果子类定义了 <code>constructor</code> 方法，子类必须在 <code>constructor</code> 方法中调用 <code>super</code> 方法，否则新建实例时会报错。这是因为子类没有自己的 <code>this</code> 对象，而是继承父类的 <code>this</code> 对象，然后对其进行加工。如果不调用 <code>super</code> 方法，子类就得不到 <code>this</code> 对象。这与 ES5 的继承有很大区别。如果子类没有显示定义 <code>constructor</code> 方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有 <code>constructor</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">constructor(...args) &#123;</div><div class="line">  super(...args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>静态方法</li>
</ul>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前加上 <code>static</code> 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这种用法和其他的面向对象语言中的静态方法很类似。而且父类的静态方法可以被子类继承，在子类的定义中，可以通过 <code>super</code> 来调用；也可以通过子类直接调用该静态方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">  static f() &#123;</div><div class="line">    return &apos;hello&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bar extends Foo &#123;</div><div class="line">  static b() &#123;</div><div class="line">    return super.f() + &apos;, too&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.f(); //hello</div><div class="line">Bar.f(); //hello</div><div class="line">Bar.b(); //hello, too</div></pre></td></tr></table></figure>
<hr>
<h2 id="6-Iterator"><a href="#6-Iterator" class="headerlink" title="6. Iterator"></a>6. Iterator</h2><p>遍历器（Iterator）作为一种机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要支持Iterator，就可以完成遍历操作。概况地讲，Iterator 有三个作用：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令 for…of 循环，Iterator接口主要供 for…of 消费。</p>
<p>Iterator的遍历过程是这样的:</p>
<ul>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。</li>
</ul>
<hr>
<h2 id="7-Module"><a href="#7-Module" class="headerlink" title="7. Module"></a>7. Module</h2><p>ES6 提出的 <code>class</code> 语法糖，在很大程度上方便了面向对象编程，但是并没有解决模块化的问题。追溯 JavaScript 的历史，一直没有添加对模块化的支持，导致在构建大型的复杂的系统时，拆分依赖，按需加载都不是很容易的事情。这也是为什么各大公司、社区争相放出各种规范的原因，比如 AMD、CMD。</p>
<p>ES6模块的设计思想，是尽量的静态化，使得在编译时就能确定模块的依赖关系，以及输入和输出的变量。而CommonJS和AMD模块，都只能在运行时确定这些东西，所以不能很好的实现按需加载。ES6的模块不是对象，而是通过 export 语句显式指定输出的代码，输入时也采用静态命令的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// ES6模块</div><div class="line">import &#123;sin, cos&#125; from &apos;Math&apos;;</div></pre></td></tr></table></figure>
<ul>
<li>export</li>
</ul>
<p>模块功能主要由两个语句构成： export 和 import 。 export 语句用于规定模块的对外接口， import 语句用于输入其他模块提供的功能。一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export 语句输出该变量。下面是一个JS文件，里面使用 export 语句输出变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//profile.js</div><div class="line">export var firstName = &apos;Michael&apos;;</div><div class="line">export var lastName = &apos;Jackson&apos;;</div><div class="line">export var year = 1958;</div></pre></td></tr></table></figure>
<p>使用 <code>export</code> 语句定义了模块的对外接口以后，其他JS文件就可以通过 <code>import</code> 语句加载这个模块（文件）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// main.js</div><div class="line">import &#123;firstName, lastName, year&#125; from &apos;./profile&apos;;</div><div class="line"></div><div class="line">function setName(element) &#123;</div><div class="line">  element.textContent = firstName + &apos; &apos; + lastName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>引入变量的时候也可以进行重命名，比如：<code>import { lastName as surname } from &#39;./profile&#39;;</code></p>
<ul>
<li>模块的整体加载</li>
</ul>
<p>从前面的例子中，我们可以看到，想要 <code>import</code> 部分函数的时候，类库的使用者必须要知道其中到底包含了哪些函数。这个时候为了给使用者提供方便，我们可以使用 <code>export default</code>来为模块指定默认输出参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// export-default.js</div><div class="line">export default function () &#123;</div><div class="line">  console.log(&apos;foo&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// import-default.js</div><div class="line">import customName from &apos;./export-default&apos;;</div><div class="line">customName(); // &apos;foo&apos;</div></pre></td></tr></table></figure>
<p>上面的 <code>export</code> 中声明了一个匿名函数，然后输出为默认值。所以在 <code>import</code> 的时候我们可以指定任意名字，因此这时 import 语句后面，不使用大括号。当然 <code>export default</code> 也适用于非匿名函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// export-default.js</div><div class="line">export default function foo() &#123;</div><div class="line">  console.log(&apos;foo&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 或者写成</div><div class="line">function foo() &#123;</div><div class="line">  console.log(&apos;foo&apos;);</div><div class="line">&#125;</div><div class="line">export default foo;</div></pre></td></tr></table></figure>
<p>上面例子中，函数名 <code>foo</code> 只在模块内部有效。加载的时候也会被视同为匿名函数。其实本质上，<code>export default</code> 就是输出一个叫做 <code>default</code> 的变量或函数，然后系统允许你为它取任意名字。</p>
<hr>
<h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><p>针对 ES6中的其他语法特性我就不在这里一一展开了，感兴趣的可以自行了解：<code>Generator、Regular Expression、Symbol、Promise、Set、Map、Binary Array、Proxy、Reflect等。</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-let-和-const&quot;&gt;&lt;a href=&quot;#1-let-和-const&quot; class=&quot;headerlink&quot; title=&quot;1.let 和 const&quot;&gt;&lt;/a&gt;1.let 和 const&lt;/h2&gt;&lt;h3 id=&quot;let&quot;&gt;&lt;a href=&quot;#let&quot; c
    
    </summary>
    
      <category term="note" scheme="https://wy08271.github.io/categories/note/"/>
    
    
      <category term="ES6" scheme="https://wy08271.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记：Restful</title>
    <link href="https://wy08271.github.io/2016/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ARestful/"/>
    <id>https://wy08271.github.io/2016/07/09/学习笔记：Restful/</id>
    <published>2016-07-09T09:32:26.000Z</published>
    <updated>2016-12-11T14:45:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Restful 一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<hr>
<p><strong>API的设计</strong> 应该有一下几点要求：</p>
<ol>
<li>当标准合理的时候遵守标准。</li>
<li>API应该对程序员友好，并且在浏览器地址栏容易输入。</li>
<li>API应该简单，直观，容易使用的同时优雅。</li>
<li>API应该具有足够的灵活性来支持上层ui。</li>
<li>API设计权衡上述几个原则。</li>
</ol>
<p><strong>REST的核心原则是将API拆分为逻辑上的资源。</strong> 这些资源通过http被操作（GET ,POST,PUT,DELETE）。</p>
<p>如何 <strong>拆分</strong> 资源，可以更有效的利用url。显然从API用户的角度来看，”资源”应该是个名词。即使你的内部数据模型和资源已经有了很好的对应，API设计的时候你仍然不需要把它们一对一的都暴露出来。这里的关键是隐藏内部资源，暴露必需的外部资源。</p>
<p>一旦定义好了要暴露的资源，你可以定义资源上允许的操作，以及这些操作和你的API的对应关系：</p>
<ul>
<li>GET /tickets # 获取ticket列表</li>
<li>GET /tickets/12 # 查看某个具体的ticket</li>
<li>POST /tickets # 新建一个ticket</li>
<li>PUT /tickets/12 # 更新ticket 12.</li>
<li>DELETE /tickets/12 #删除ticekt 12</li>
</ul>
<p>可以看出使用REST的好处在于可以充分利用http的强大实现对资源的CURD功能。</p>
<hr>
<h2 id="常用的Http状态码"><a href="#常用的Http状态码" class="headerlink" title="常用的Http状态码"></a>常用的Http状态码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">200 ok  - 成功返回状态，对应，GET,PUT,PATCH,DELETE.</div><div class="line">201 created  - 成功创建。</div><div class="line">304 not modified   - HTTP缓存有效。</div><div class="line">400 bad request   - 请求格式错误。</div><div class="line">401 unauthorized   - 未授权。</div><div class="line">403 forbidden   - 鉴权成功，但是该用户没有权限。</div><div class="line">404 not found - 请求的资源不存在</div><div class="line">405 method not allowed - 该http方法不被允许。</div><div class="line">410 gone - 这个url对应的资源现在不可用。</div><div class="line">415 unsupported media type - 请求类型错误。</div><div class="line">422 unprocessable entity - 校验错误时用。</div><div class="line">429 too many request - 请求过多。</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Restful 一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;API的设计&lt;/strong&gt; 应该有一
    
    </summary>
    
      <category term="node" scheme="https://wy08271.github.io/categories/node/"/>
    
    
      <category term="Restful" scheme="https://wy08271.github.io/tags/Restful/"/>
    
      <category term="api" scheme="https://wy08271.github.io/tags/api/"/>
    
      <category term="http" scheme="https://wy08271.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记：Markdown</title>
    <link href="https://wy08271.github.io/2016/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMarkdown/"/>
    <id>https://wy08271.github.io/2016/07/04/学习笔记：Markdown/</id>
    <published>2016-07-04T02:01:17.000Z</published>
    <updated>2016-12-11T14:43:11.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="段落前加空格："><a href="#段落前加空格：" class="headerlink" title="段落前加空格："></a>段落前加空格：</h4><p><code>&amp;ensp;</code>来输入一个空格。 <code>&amp;emsp;</code>来输入两个空格。</p>
<h4 id="居中："><a href="#居中：" class="headerlink" title="居中："></a>居中：</h4><p><code>&lt;center&gt;南宫调&lt;/center&gt;</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;段落前加空格：&quot;&gt;&lt;a href=&quot;#段落前加空格：&quot; class=&quot;headerlink&quot; title=&quot;段落前加空格：&quot;&gt;&lt;/a&gt;段落前加空格：&lt;/h4&gt;&lt;p&gt;&lt;code&gt;&amp;amp;ensp;&lt;/code&gt;来输入一个空格。 &lt;code&gt;&amp;amp;emsp;&lt;/
    
    </summary>
    
      <category term="note" scheme="https://wy08271.github.io/categories/note/"/>
    
    
      <category term="markdown" scheme="https://wy08271.github.io/tags/markdown/"/>
    
      <category term="学习笔记" scheme="https://wy08271.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记：Flyway</title>
    <link href="https://wy08271.github.io/2016/06/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AFlyway/"/>
    <id>https://wy08271.github.io/2016/06/28/学习笔记：Flyway/</id>
    <published>2016-06-28T01:35:01.000Z</published>
    <updated>2016-12-11T14:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>  Flyway is an open-source database migration tool. It strongly favors simplicity and convention over configuration.   It is based around just 6 basic commands: Migrate, Clean, Info, Validate, Baseline and Repair.   Migrations can be written in SQL (database-specific syntax (such as PL/SQL, T-SQL, …) is supported) or Java (for advanced data transformations or dealing with LOBs).   It has a Command-line client. If you are on the JVM, we recommend using the Java API (also works on Android) for migrating the database on application startup. Alternatively, you can also use the Maven plugin, Gradle plugin, SBT plugin or the Ant tasks.   And if that not enough, there are plugins available for Spring Boot, Dropwizard, Grails, Play, Griffon, Grunt, Ninja and more!</p>
<hr>
<h1 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h1><p>需要在pom.xml文件中加入flywaydb的插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.1&lt;/version&gt;</div><div class="line">    &lt;configuration&gt;</div><div class="line">    ....</div><div class="line">    &lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>配置方法一：在pom.xml里配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">...</div><div class="line">  &lt;configuration&gt;</div><div class="line">    &lt;user&gt;myUser&lt;/user&gt;</div><div class="line">    &lt;password&gt;mySecretPwd&lt;/password&gt;</div><div class="line">    &lt;schemas&gt;</div><div class="line">        &lt;schema&gt;schema1&lt;/schema&gt;</div><div class="line">        &lt;schema&gt;schema2&lt;/schema&gt;</div><div class="line">        &lt;schema&gt;schema3&lt;/schema&gt;</div><div class="line">    &lt;/schemas&gt;</div><div class="line">    &lt;placeholders&gt;</div><div class="line">          &lt;keyABC&gt;valueXYZ&lt;/keyABC&gt;</div><div class="line">          &lt;otherplaceholder&gt;value123&lt;/otherplaceholder&gt;</div><div class="line">    &lt;/placeholders&gt;</div><div class="line">  &lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>配置方法二：外部的配置文件来配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">flyway.user=</div><div class="line">flyway.password=</div><div class="line">flyway.schemas=schema1,schema2,schema3</div><div class="line">flyway.placeholders.keyABC=</div><div class="line">flyway.placeholders.otherplaceholder=</div></pre></td></tr></table></figure>
</li>
<li><p>配置方法三：执行mvn时通过指定参数flyway.configFile的值来指定配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn -Dflyway.configFile=myConfig.properties</div></pre></td></tr></table></figure>
</li>
<li><p>配置方法四：使用外部配置文件的方式进行配置，默认的flyway.properties文件和pom.xml在相同的路径下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">flyway.user=</div><div class="line">flyway.password=</div><div class="line">flyway.driver=org.postgresql.Driver</div><div class="line">flyway.url=jdbc:postgresql://localhost:5432/wjia</div><div class="line">flyway.locations=classpath:db/migration</div><div class="line">flyway.sqlMigrationPrefix=V</div><div class="line">flyway.sqlMigrationSeparator=__</div><div class="line">flyway.sqlMigrationSuffix&gt;=.sql</div><div class="line">flyway.encoding=UTF-8</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="六个命令"><a href="#六个命令" class="headerlink" title="六个命令"></a>六个命令</h1><ul>
<li><p>Migrate</p>
<p>flyway的最重要的功能当然是完成数据库迁移了，使用mvn flyway:migrate命令就可以方便的帮助我们执行flyway.locations目录中定义的migration任务。由于我们的使用了外部的flyway配置文件，因此在执行migration任务时需要加上参数flyway.properties来指定配置文件的位置。所以，在我们的工程中需要执行的任务为：</p>
<p><code>mvn flyway:migrate -Dflyway.configFile=localPath/flyway.properties</code></p>
<p>其中<code>localPath/</code>为<code>flyway.properties</code>文件在本地的路径。</p>
</li>
<li><p>Clean</p>
<p>如果我们想初始化数据库，删除所有的表和数据，那么只需要执行命令：</p>
<p><code>mvn flyway:clean</code></p>
</li>
<li><p>Info</p>
<p>如果我们想知道所有migration的详细信息，可以通过执行下面命令来打印信息：</p>
<p><code>mvn flyway:info</code></p>
<p>执行之后，Terminal中会打印出所有migration的详细信息，其中包括版本号，描述，执行时间，以及状态.</p>
</li>
<li><p>Validate</p>
<p><code>mvn flyway:validate</code> 用来执行已经执行过的migration任务.</p>
</li>
<li><p>Baseline</p>
<p><code>mvn flyway:baseline</code> 用来回滚数据库到一个配置文件中设定好的baseline.</p>
</li>
<li><p>Repair</p>
<p><code>mvn flyway:repair</code> 用来删除执行失败的migration任务.</p>
</li>
</ul>
<hr>
<h1 id="查看官方文档"><a href="#查看官方文档" class="headerlink" title="查看官方文档"></a>查看官方文档</h1><p>更多关于flyway的详细用法，请参见其<a href="https://flywaydb.org/documentation/" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  Flyway is an open-source database migration tool. It strongly favors simplicity and convention over configuration.   It is based around
    
    </summary>
    
      <category term="note" scheme="https://wy08271.github.io/categories/note/"/>
    
    
      <category term="插件" scheme="https://wy08271.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="maven" scheme="https://wy08271.github.io/tags/maven/"/>
    
      <category term="构建工具" scheme="https://wy08271.github.io/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
      <category term="flyway" scheme="https://wy08271.github.io/tags/flyway/"/>
    
  </entry>
  
</feed>
